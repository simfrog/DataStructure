# 12. Weighted graph

## 1. 개념  
간선에 비용이나 가중치가 할당된 그래프  
정점의 연결 정보뿐만 아니라 연결에 필요한 비용을 함께 표현할 수 있음  
G = (V, E, w)  
w(e) -> 간선 e의 강도(weight), 비용(cost), 길이(length)  
ex) 컴퓨터 네트워크, 고속도로 연결 정보  

## 3. 최소 비용 신장 트리(MST : minimumspanning tree)  
### 3-1. 개념  
어떤 그래프의 신장 트리들 중 사용된 간선들의 가중치 합이 최소인 신장 트리  
#### 모든 정점들을 가장 적은 수의 간선과 비용으로 연결  
    * 조건  
    1. 간선의 가중치 합이 최소이어야 함  
    2. 반드시 (n-1)개의 간선만 사용  
    3. 사이클이 포함되어서는 안 됨
### 3-2. Kruskal의 MST 알고리즘  
* #### Kruskal 알고리즘  
    탐욕적인 방법(greedy method) 알고리즘 설계에서 중요한 기법 중 하나 사용  
    어떤 결정을 할 때마다 "그 순간에 최적"이라고 생각되는 것을 선택하는 방법  
    순간에 최적이라고 판단했던 선택을 모아 최종 답을 만들었을 때 이것이 궁극적으로 최적이라는 보장은 없음. 따라서 탐용적인 방법은 항상 최적의 해답을 주는지 반드시 검증해야함  
    => Kruskal 알고리즘은 최적의 해답을 주는 것으로 증명  

각 단계에서 사이클을 이루지 않는 최소 비용 간선 선택  
이러한 과정을 반복하여 최적 해답을 구함  
<pre><code>
kruskal()  
  
1. 그래프의 모든 간선을 가중치에 따라 오름차순으로 정렬.  
2. 가장 가중치가 작은 간선 e를 뽑음.  
3. e를 신장 트리에 넣을 경우 사이클이 생기면 삽입하지 않고 2번으로 이동.  
4. 사이클이 생기지 않으면 최소 신장 트리에 삽입.  
5. n-1개의 간선이 삽입될 때 까지 2번으로 이동.
</code></pre>  
![kruskal](https://user-images.githubusercontent.com/31130917/104700103-03a75000-5757-11eb-840f-238c3126437b.png)  
<출처 : https://gmlwjd9405.github.io/2018/08/29/algorithm-kruskal-mst.html>  
  
* #### union-find 연산  
#### union(x, y) : 원소 x와 원소 y가 속해있는 집합을 입력으로 받아 합집합을 만드는 연산  
#### find(x) : 여러 집합들 중 원소 x가 속해있는 집합을 반환하는 연산  
=> 사이클 검사  
    * 초기에는 모든 정점이 각각 고유한 집합  
    * 최소 가중치 간선 (u,v)가 선택되면 u와 v가 각각 속한 집합을 찾음  
      이때 find(u)와 find(v)연산을 수행  
    * 두 집합이 같으면 사이클이 발생하는 상황 -> 간선을 버림  
    * 두 집합이 다르면 간선을 삽입하고 집합을 하나로 합침(union(u,v))
### 3-3. Prim의 MST 알고리즘  
* #### Prim 알고리즘  
    하나의 정점에서부터 시작하여 트리를 단계적으로 확장해나가는 방법  
    처음에는 시작 정점만 트리에 포함  
    지금까지 만들어진 트리에 인접한 정점들 중 간선의 가중치가 가장 작은 정점을 선택하여 트리 확장  
    이 과정을 트리가 n-1개의 간선을 가질 때까지 반복
<pre><code>
Prim()  
  
1. 그래프에서 시작 정점을 선택하여 초기 트리를 만듬.  
2. 현지 트리 정점들과 인접한 정점들 중 가장 가중치가 작은 정점 v 선택.  
3. 이 정점 v와 이때의 간선을 트리에 추가.  
5. 모든 정점이 삽입될 때 까지 2번으로 이동.
</code></pre>  
![kruskal](https://user-images.githubusercontent.com/31130917/104908087-496b4f00-59c9-11eb-9b95-6ed7b01b7d2d.png)  
<출처 : https://gmlwjd9405.github.io/2018/08/30/algorithm-prim-mst.html>  
* 차이점  
    Kruskal 알고리즘 -> 간선을 기반으로 하는 알고리즘  
    Prim 알고리즘 -> 정점을 기반  

## 4. 최단 경로  
### 4-1. 개념  
가중치 그래프에서 정점 u와 정점 v를 연결하는 경로 중에서 간선들의 가중치 함이 최소가 되는 경로를 찾는 문제  
### 4-2. Dijkstra의 최단 경로 알고리즘  
하나의 시작 정점 v에서 모든 다른 정점까지의 최단 경로를 찾는 알고리즘  
<pre><code>
// 입력 : 가중치 그래프 G, 가중치는 음수가 아님.  
// 출력 : dist 배열, dist[u]는 v에서 u까지의 최단거리.  
shortestPath(v)  
  
    S<-{v}  
    for 각 정점 w는 G에 속함 do  
        dist[w]<-weight[v][w];  
    while 모든 정점이 s에 포함되지 않으면 do  
        u<-짐합 S에 속하지 않는 정점 중에서 최소 distance 정점;  
        S<-S와{u}의 합집합  
        for u에 인접하고 S에 있지 않은 각 정점 z do  
            if dist[u]+weight[u][z] < dist[z]  
                then dist[z]<-dist[u]+weight[u][z];
</code></pre>  
### 4-3. Floyd의 최단 경로 알고리즘  
그래프의 모든 정점 사이의 최단 경로를 한꺼번에 찾아줌  
<pre><code>
floyd(G)  
  
    for k <- to n - 1  
        for i <- 0 to n - 1  
            for j <- 0 to n - 1  
                A[i][j] = min(A[i][j], A[i][k] + A[k][j]);
</code></pre>  